# cjm-fasthtml-plugins


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Install

``` bash
pip install cjm_fasthtml_plugins
```

## Project Structure

    nbs/
    ├── components/ (2)
    │   ├── html_ids.ipynb  # Centralized HTML ID constants for plugin selector components
    │   └── selector.ipynb  # Reusable plugin selection UI components with multiple display strategies
    ├── core/ (3)
    │   ├── execution_mode.ipynb  # Enum definitions for plugin execution modes (in-process, subprocess, Docker, cloud, etc.)
    │   ├── metadata.ipynb        # Plugin metadata structures for tracking plugin information and resources
    │   └── registry.ipynb        # Unified plugin registry for managing multiple domain-specific plugin systems with configuration persistence
    ├── protocols/ (2)
    │   ├── cloud_aware.ipynb  # Protocol for plugins that use cloud or remote computing resources
    │   └── lifecycle.ipynb    # Protocol for plugins that manage child processes, containers, or other external resources
    └── utils/ (1)
        └── helpers.ipynb  # Utility functions for plugin registry operations

Total: 8 notebooks across 5 directories

## Module Dependencies

``` mermaid
graph LR
    components_html_ids[components.html_ids<br/>HTML IDs]
    components_selector[components.selector<br/>Plugin Selector]
    core_execution_mode[core.execution_mode<br/>Execution Mode]
    core_metadata[core.metadata<br/>Metadata]
    core_registry[core.registry<br/>Registry]
    protocols_cloud_aware[protocols.cloud_aware<br/>Cloud-Aware Protocol]
    protocols_lifecycle[protocols.lifecycle<br/>Lifecycle Protocol]
    utils_helpers[utils.helpers<br/>Helpers]

    components_selector --> core_execution_mode
    components_selector --> components_html_ids
    components_selector --> core_metadata
    core_metadata --> core_execution_mode
    core_registry --> core_metadata
    core_registry --> core_execution_mode
    protocols_cloud_aware --> core_metadata
    protocols_cloud_aware --> core_execution_mode
    protocols_lifecycle --> core_execution_mode
    utils_helpers --> core_metadata
    utils_helpers --> core_execution_mode
```

*11 cross-module dependencies detected*

## CLI Reference

No CLI commands found in this project.

## Module Overview

Detailed documentation for each module in the project:

### Cloud-Aware Protocol (`cloud_aware.ipynb`)

> Protocol for plugins that use cloud or remote computing resources

#### Import

``` python
from cjm_fasthtml_plugins.protocols.cloud_aware import (
    CloudAwarePlugin,
    is_cloud_aware,
    has_active_cloud_resources,
    get_total_estimated_cost
)
```

#### Functions

``` python
def is_cloud_aware(plugin: Any  # Plugin instance to check
                  ) -> bool:  # True if plugin implements the protocol
    "Check if a plugin implements the CloudAwarePlugin protocol."
```

``` python
def has_active_cloud_resources(plugin: Any  # Plugin instance
                               ) -> bool:  # True if plugin has running cloud resources
    "Check if plugin has active cloud resources."
```

``` python
def get_total_estimated_cost(plugins: List[Any],  # List of plugin instances
                            duration_hours: float = 1.0  # Duration to estimate for
                           ) -> float:  # Total estimated cost in USD
    "Get total estimated cost for multiple plugins."
```

#### Classes

``` python
@runtime_checkable
class CloudAwarePlugin(Protocol):
    "Protocol for plugins that use cloud/remote resources."
    
    def get_remote_resource_info(self) -> Optional[RemoteResourceInfo]:  # RemoteResourceInfo if resources are provisioned, None otherwise
            """Get information about remote/cloud resources."""
            ...
        
        def provision_remote_resource(self, **config) -> RemoteResourceInfo:  # RemoteResourceInfo with details about provisioned resource
        "Get information about remote/cloud resources."
    
    def provision_remote_resource(self, **config) -> RemoteResourceInfo:  # RemoteResourceInfo with details about provisioned resource
            """Provision cloud resources (VM, container, etc.)."""
            ...
        
        def check_remote_resource_status(self) -> str:  # Status string (e.g., 'running', 'stopped', 'provisioning')
        "Provision cloud resources (VM, container, etc.)."
    
    def check_remote_resource_status(self) -> str:  # Status string (e.g., 'running', 'stopped', 'provisioning')
            """Check status of remote resource."""
            ...
        
        def terminate_remote_resource(self) -> bool:  # True if termination succeeded
        "Check status of remote resource."
    
    def terminate_remote_resource(self) -> bool:  # True if termination succeeded
            """Terminate/stop cloud resources to avoid costs."""
            ...
        
        def estimate_cost(self, 
                         duration_hours: float  # Estimated runtime in hours
                        ) -> float:  # Estimated cost in USD
        "Terminate/stop cloud resources to avoid costs."
    
    def estimate_cost(self,
                         duration_hours: float  # Estimated runtime in hours
                        ) -> float:  # Estimated cost in USD
        "Estimate cost for running this duration."
```

### Execution Mode (`execution_mode.ipynb`)

> Enum definitions for plugin execution modes (in-process, subprocess,
> Docker, cloud, etc.)

#### Import

``` python
from cjm_fasthtml_plugins.core.execution_mode import (
    PluginExecutionMode,
    CloudProviderType
)
```

#### Classes

``` python
class PluginExecutionMode(Enum):
    "Categorizes plugins by their execution environment, from in-process to cloud deployments."
```

``` python
class CloudProviderType(Enum):
    "Cloud providers and GPU rental services for remote execution."
```

### Helpers (`helpers.ipynb`)

> Utility functions for plugin registry operations

#### Import

``` python
from cjm_fasthtml_plugins.utils.helpers import (
    filter_plugins_by_execution_mode,
    get_cloud_plugins,
    get_local_plugins,
    get_configured_plugins,
    get_unconfigured_plugins,
    get_plugin_stats
)
```

#### Functions

``` python
def filter_plugins_by_execution_mode(
    plugins: List[PluginMetadata],  # List of plugin metadata
    mode: PluginExecutionMode  # Execution mode to filter by
) -> List[PluginMetadata]:  # Filtered list
    "Filter plugins by execution mode."
```

``` python
def get_cloud_plugins(plugins: List[PluginMetadata]  # List of plugin metadata
                     ) -> List[PluginMetadata]:  # List of cloud/remote plugins
    "Get all cloud/remote execution plugins."
```

``` python
def get_local_plugins(plugins: List[PluginMetadata]  # List of plugin metadata
                     ) -> List[PluginMetadata]:  # List of local plugins
    "Get all local execution plugins."
```

``` python
def get_configured_plugins(plugins: List[PluginMetadata]  # List of plugin metadata
                          ) -> List[PluginMetadata]:  # List of configured plugins
    "Get plugins that have saved configuration."
```

``` python
def get_unconfigured_plugins(plugins: List[PluginMetadata]  # List of plugin metadata
                            ) -> List[PluginMetadata]:  # List of unconfigured plugins
    "Get plugins that need configuration."
```

``` python
def get_plugin_stats(plugins: List[PluginMetadata]  # List of plugin metadata
                    ) -> Dict[str, Any]:  # Dictionary with plugin statistics
    "Get statistics about a list of plugins."
```

### HTML IDs (`html_ids.ipynb`)

> Centralized HTML ID constants for plugin selector components

#### Import

``` python
from cjm_fasthtml_plugins.components.html_ids import (
    PluginSelectorHtmlIds
)
```

#### Classes

``` python
class PluginSelectorHtmlIds:
    "HTML ID constants for plugin selector components."
    
    def as_selector(
            id_str: str  # The HTML ID to convert
        ) -> str:  # CSS selector with # prefix
        "Convert an ID to a CSS selector format."
```

### Lifecycle Protocol (`lifecycle.ipynb`)

> Protocol for plugins that manage child processes, containers, or other
> external resources

#### Import

``` python
from cjm_fasthtml_plugins.protocols.lifecycle import (
    LifecycleAwarePlugin,
    is_lifecycle_aware,
    get_all_managed_pids
)
```

#### Functions

``` python
def is_lifecycle_aware(plugin: Any  # Plugin instance to check
                      ) -> bool:  # True if plugin implements the protocol
    "Check if a plugin implements the LifecycleAwarePlugin protocol."
```

``` python
def get_all_managed_pids(plugin: Any  # Plugin instance
                        ) -> List[int]:  # List of all PIDs (empty if plugin not lifecycle-aware)
    "Get all PIDs managed by a plugin (including children)."
```

#### Classes

``` python
@runtime_checkable
class LifecycleAwarePlugin(Protocol):
    "Protocol for plugins that manage external resources like child processes, containers, or cloud resources."
    
    def get_execution_mode(self) -> PluginExecutionMode:  # PluginExecutionMode indicating how this plugin executes
            """Get the execution mode of this plugin."""
            ...
        
        def get_child_pids(self) -> List[int]:  # List of process IDs (empty list if no child processes)
        "Get the execution mode of this plugin."
    
    def get_child_pids(self) -> List[int]:  # List of process IDs (empty list if no child processes)
            """Get PIDs of any child processes managed by this plugin."""
            ...
        
        def get_managed_resources(self) -> Dict[str, Any]:  # Dictionary with resource information
        "Get PIDs of any child processes managed by this plugin."
    
    def get_managed_resources(self) -> Dict[str, Any]:  # Dictionary with resource information
            """Get information about managed resources (server URLs, container IDs, conda envs, etc.)."""
            ...
        
        def force_cleanup(self) -> None
        "Get information about managed resources (server URLs, container IDs, conda envs, etc.)."
    
    def force_cleanup(self) -> None
        "Force cleanup of all managed resources (kill processes, stop containers, etc.)."
```

### Metadata (`metadata.ipynb`)

> Plugin metadata structures for tracking plugin information and
> resources

#### Import

``` python
from cjm_fasthtml_plugins.core.metadata import (
    RemoteResourceInfo,
    PluginMetadata
)
```

#### Classes

``` python
@dataclass
class RemoteResourceInfo:
    "Information about a remote/cloud resource used by a plugin."
    
    provider: CloudProviderType  # Cloud provider or service
    region: Optional[str]  # Cloud region/zone
    instance_id: Optional[str]  # VM/instance identifier
    job_id: Optional[str]  # Job/task identifier on remote system
    endpoint_url: Optional[str]  # HTTP endpoint for API access
    ssh_host: Optional[str]  # SSH host for remote access
    ssh_port: int = 22  # SSH port number
    status: str = 'unknown'  # Current status (provisioning, running, stopping, stopped)
    resource_type: Optional[str]  # Instance type (e.g., 'p3.2xlarge', 'n1-standard-8')
    gpu_count: int = 0  # Number of GPUs
    gpu_type: Optional[str]  # GPU model (e.g., 'V100', 'A100', 'H100')
    estimated_cost_per_hour: Optional[float]  # Estimated hourly cost in USD
    metadata: Dict[str, Any] = field(...)  # Additional provider-specific metadata
```

``` python
@dataclass
class PluginMetadata:
    "Metadata describing a plugin for display and resource management without loading the plugin instance."
    
    name: str  # Internal plugin identifier
    category: str  # Plugin category string (application-defined)
    title: str  # Display title for the plugin
    config_schema: Dict[str, Any]  # JSON Schema for plugin configuration
    description: Optional[str]  # Plugin description
    version: Optional[str]  # Plugin version
    is_configured: bool = False  # Whether the plugin has saved configuration
    execution_mode: PluginExecutionMode = PluginExecutionMode.IN_PROCESS  # How the plugin executes
    manages_child_processes: bool = False  # Whether plugin spawns child processes
    manages_external_resources: bool = False  # Whether plugin manages Docker/servers/etc.
    spawned_pids: List[int] = field(...)  # List of child process PIDs
    container_id: Optional[str]  # Docker container ID if applicable
    conda_env_name: Optional[str]  # Conda environment name if applicable
    remote_resource: Optional[RemoteResourceInfo]  # Remote resource information if applicable
    
    def get_unique_id(self) -> str:  # String in format 'category_name'
            """Generate unique ID for this plugin."""
            return f"{self.category}_{self.name}"
        
        def is_local_execution(self) -> bool:  # True if execution is local
        "Generate unique ID for this plugin."
    
    def is_local_execution(self) -> bool:  # True if execution is local
            """Check if plugin executes locally (not cloud/remote)."""
            local_modes = {
                PluginExecutionMode.IN_PROCESS,
                PluginExecutionMode.SUBPROCESS,
                PluginExecutionMode.DOCKER,
                PluginExecutionMode.CONDA_ENV,
                PluginExecutionMode.EXTERNAL_SERVICE
            }
            return self.execution_mode in local_modes
        
        def is_cloud_execution(self) -> bool:  # True if execution is cloud/remote
        "Check if plugin executes locally (not cloud/remote)."
    
    def is_cloud_execution(self) -> bool:  # True if execution is cloud/remote
            """Check if plugin executes on cloud/remote resources."""
            return not self.is_local_execution()
        
        def has_active_resources(self) -> bool:  # True if plugin has child processes, containers, or cloud resources
        "Check if plugin executes on cloud/remote resources."
    
    def has_active_resources(self) -> bool:  # True if plugin has child processes, containers, or cloud resources
        "Check if plugin has active managed resources."
```

### Registry (`registry.ipynb`)

> Unified plugin registry for managing multiple domain-specific plugin
> systems with configuration persistence

#### Import

``` python
from cjm_fasthtml_plugins.core.registry import (
    T,
    UnifiedPluginRegistry
)
```

#### Classes

```` python
class UnifiedPluginRegistry:
    def __init__(self, 
                 config_dir: Optional[Path] = None  # Directory for plugin configuration files (default: 'configs')
                )
    "Unified registry for multiple domain-specific plugin systems with configuration persistence."
    
    def __init__(self,
                     config_dir: Optional[Path] = None  # Directory for plugin configuration files (default: 'configs')
                    )
        "Initialize the unified plugin registry."
    
    def register_plugin_manager(
            self,
            category: str,  # Category name (e.g., "transcription", "llm")
            manager: Any,  # Domain-specific plugin manager
            display_name: Optional[str] = None,  # Display name for UI
            auto_discover: bool = True  # Automatically discover plugins?
        ) -> List[PluginMetadata]:  # List of discovered plugin metadata
        "Register a domain-specific plugin manager."
    
    def register_plugin_system(
            self,
            category: str,  # Category name (e.g., "transcription", "llm")
            plugin_interface: Type,  # Plugin interface class (e.g., TranscriptionPlugin)
            display_name: Optional[str] = None,  # Display name for UI
            auto_discover: bool = True  # Automatically discover plugins?
        ) -> List[PluginMetadata]:  # List of discovered plugin metadata
        "Create and register a plugin system in one step.

This is a convenience method that creates a PluginManager with the
specified interface and registers it with the registry.

Example:
    ```python
    from cjm_transcription_plugin_system.plugin_interface import TranscriptionPlugin
    
    registry = UnifiedPluginRegistry()
    
    # Instead of:
    # manager = PluginManager(plugin_interface=TranscriptionPlugin)
    # registry.register_plugin_manager(category="transcription", manager=manager)
    
    # Do this:
    registry.register_plugin_system(
        category="transcription",
        plugin_interface=TranscriptionPlugin,
        display_name="Transcription"
    )
    ```

Returns:
    List of discovered plugin metadata"
    
    def get_manager(
            self,
            category: str,  # Category name
            manager_type: Optional[Type[T]] = None  # Optional type hint for IDE autocomplete
        ) -> Optional[T]:  # Plugin manager instance
        "Get plugin manager for a specific category."
    
    def get_categories(self) -> List[str]:  # Sorted list of category names
            """Get all registered categories."""
            return sorted(self._categories.keys())
        
        def get_category_display_name(self, 
                                       category: str  # Category name
                                      ) -> str:  # Display name or category name if not set
        "Get all registered categories."
    
    def get_category_display_name(self,
                                       category: str  # Category name
                                      ) -> str:  # Display name or category name if not set
        "Get display name for a category."
    
    def get_plugin(self,
                       unique_id: str  # Plugin unique identifier (format: 'category_name')
                      ) -> Optional[PluginMetadata]:  # Plugin metadata if found, None otherwise
        "Get plugin metadata by unique ID."
    
    def get_plugins_by_category(self,
                                    category: str  # Category name
                                   ) -> List[PluginMetadata]:  # List of plugin metadata for the category
        "Get all plugins in a category."
    
    def get_all_plugins(self) -> List[PluginMetadata]:  # List of all plugin metadata
            """Get all plugins across all categories."""
            return list(self._plugins.values())
        
        def get_categories_with_plugins(self) -> List[str]:  # Sorted list of categories with plugins
        "Get all plugins across all categories."
    
    def get_categories_with_plugins(self) -> List[str]:  # Sorted list of categories with plugins
            """Get categories that have registered plugins."""
            categories = set(p.category for p in self._plugins.values())
            return sorted(categories)
        
        def load_plugin_config(self, 
                              unique_id: str  # Plugin unique identifier
                             ) -> Dict[str, Any]:  # Configuration dictionary (empty if no config exists)
        "Get categories that have registered plugins."
    
    def load_plugin_config(self,
                              unique_id: str  # Plugin unique identifier
                             ) -> Dict[str, Any]:  # Configuration dictionary (empty if no config exists)
        "Load saved configuration for a plugin."
    
    def save_plugin_config(self,
                              unique_id: str,  # Plugin unique identifier
                              config: Dict[str, Any]  # Configuration dictionary to save
                             ) -> bool:  # True if save succeeded, False otherwise
        "Save configuration for a plugin."
    
    def delete_plugin_config(self,
                                unique_id: str  # Plugin unique identifier
                               ) -> bool:  # True if deletion succeeded, False otherwise
        "Delete saved configuration for a plugin."
````

#### Variables

``` python
T
```

### Plugin Selector (`selector.ipynb`)

> Reusable plugin selection UI components with multiple display
> strategies

#### Import

``` python
from cjm_fasthtml_plugins.components.selector import (
    format_execution_mode,
    get_execution_badge_color,
    extract_plugin_features,
    render_plugin_details,
    render_dropdown_selector,
    render_comparison_table,
    render_plugin_selector
)
```

#### Functions

``` python
def format_execution_mode(
    mode: PluginExecutionMode  # Execution mode enum
) -> str:  # Human-readable string
    "Format execution mode for display."
```

``` python
def get_execution_badge_color(
    mode: PluginExecutionMode  # Execution mode enum
) -> str:  # DaisyUI badge color class
    "Get badge color for execution mode."
```

``` python
def extract_plugin_features(
    plugin: PluginMetadata,  # Plugin metadata
    config: Optional[Dict[str, Any]] = None  # Optional plugin configuration
) -> List[tuple]:  # List of (label, value, badge_color) tuples
    "Extract key features from plugin metadata for display."
```

``` python
def render_plugin_details(
    plugin: PluginMetadata,  # Plugin to display
    config: Optional[Dict[str, Any]] = None  # Optional plugin configuration
) -> FT:  # Card element with plugin details
    "Render detailed information about a plugin."
```

``` python
def render_dropdown_selector(
    plugins: List[PluginMetadata],  # Available plugins
    selected_plugin_id: Optional[str] = None,  # Currently selected plugin ID
    selection_endpoint: str = None,  # HTMX endpoint for confirming selection
    details_endpoint: Optional[str] = None,  # HTMX endpoint for updating details (optional)
    target_id: str = None,  # HTMX target element ID for final selection
    label: str = "Select Plugin",  # Label for the dropdown
    confirm_button_text: str = "Continue with Selected Plugin",  # Text for confirmation button
    get_plugin_config: Optional[Callable[[str], Dict[str, Any]]] = None,  # Function to get plugin config
    show_comparison_toggle: bool = True  # Whether to show comparison table toggle
) -> FT:  # Complete plugin selector UI
    """
    Render plugin selector with dropdown and details panel.
    
    The dropdown updates the details panel for browsing, while an explicit
    button confirms the selection and proceeds to the next step.
    """
```

``` python
def render_comparison_table(
    plugins: List[PluginMetadata],  # Plugins to compare
    selected_plugin_id: Optional[str] = None,  # Currently selected plugin ID
    get_plugin_config: Optional[Callable[[str], Dict[str, Any]]] = None  # Function to get plugin config
) -> FT:  # Table element with plugin comparison
    "Render a comparison table of all plugins."
```

``` python
def render_plugin_selector(
    plugins: List[PluginMetadata],  # Available plugins
    selected_plugin_id: Optional[str] = None,  # Currently selected plugin ID
    selection_endpoint: str = None,  # HTMX endpoint for selection
    target_id: str = None,  # HTMX target element ID
    strategy: str = "dropdown",  # UI strategy: "dropdown" or "comparison"
    get_plugin_config: Optional[Callable[[str], Dict[str, Any]]] = None,  # Function to get plugin config
    **kwargs  # Additional strategy-specific options
) -> FT:  # Plugin selector UI
    """
    Render plugin selector with the specified UI strategy.
    
    Strategies:
    - "dropdown": Dropdown selector with details panel (default)
    - "comparison": Comparison table of all plugins
    """
```
